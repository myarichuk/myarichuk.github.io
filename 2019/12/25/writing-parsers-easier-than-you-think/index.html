<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Hello ANTLR (writing parsers is easier than you think!) | Graymatter Developer</title><meta name="author" content="Michael Yarichuk"><meta name="copyright" content="Michael Yarichuk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="After playing around with the awesome ANTLR for a while (it is a parser generator, in case you are not familiar with it), I decided to write something that could have helped me before I started lookin">
<meta property="og:type" content="article">
<meta property="og:title" content="Hello ANTLR (writing parsers is easier than you think!)">
<meta property="og:url" content="https://www.graymatterdeveloper.com/2019/12/25/writing-parsers-easier-than-you-think/index.html">
<meta property="og:site_name" content="Graymatter Developer">
<meta property="og:description" content="After playing around with the awesome ANTLR for a while (it is a parser generator, in case you are not familiar with it), I decided to write something that could have helped me before I started lookin">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.graymatterdeveloper.com/2019/11/21/antlr-error-handling/antlr.jpg">
<meta property="article:published_time" content="2019-12-25T08:21:44.000Z">
<meta property="article:modified_time" content="2019-12-25T08:21:44.000Z">
<meta property="article:author" content="Michael Yarichuk">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="ANTLR">
<meta property="article:tag" content="Parsers">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.graymatterdeveloper.com/2019/11/21/antlr-error-handling/antlr.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.graymatterdeveloper.com/2019/12/25/writing-parsers-easier-than-you-think/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-125949801-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-125949801-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hello ANTLR (writing parsers is easier than you think!)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-12-25 08:21:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Graymatter Developer" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/1473701" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tag"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-envelope-open"></i><span> Contact</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2019/11/21/antlr-error-handling/antlr.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Graymatter Developer"><span class="site-name">Graymatter Developer</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tag"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-envelope-open"></i><span> Contact</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Hello ANTLR (writing parsers is easier than you think!)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2019-12-25T08:21:44.000Z" title="Created 2019-12-25 08:21:44">2019-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2019-12-25T08:21:44.000Z" title="Updated 2019-12-25 08:21:44">2019-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming/">Programming</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming/Parsers/">Parsers</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Hello ANTLR (writing parsers is easier than you think!)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>After playing around with the awesome ANTLR for a while (it is a <a target="_blank" rel="noopener" href="https://www.antlr.org/">parser generator</a>, in case you are not familiar with it), I decided to write something that could have helped me before I started looking into parsers. This post assumes you have heard of parsers but never actually wrote one.</p>
<h2 id="A-word-or-two-on-what-parsers-are"><a href="#A-word-or-two-on-what-parsers-are" class="headerlink" title="A word (or two) on what parsers are"></a>A word (or two) on <em>what</em> parsers are</h2><p>When you have a text with known syntax, be it structured logging, programming language or configuration files and you want to parse it with an application, you can use a parser that would transform text to objects in an application.<br>Usually parsers have two components</p>
<ul>
<li>Lexer: transforms text into stream of known tokens, such as ‘comma’, ‘variable identifier’ or ‘number’</li>
<li>Parser: processes Lexer’s tokens according to grammar rules and turns them into application objects (abstract syntax trees)</li>
</ul>
<blockquote>
<p>Note: this is pretty much a description of a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interpreter_pattern">GoF design pattern</a></p>
</blockquote>
<pre class="mermaid">graph LR;
    A[Text]-->B[Lexer]
    B-->C[Parser]
    C-->D[Abstract Syntax Tree (AST)]

    style A fill:white,stroke:#333,stroke-width:1px
    style B fill:#e8e4da,stroke:#333,stroke-width:2px
    style C fill:#c2beb4,stroke:#333,stroke-width:2px
    style D fill:#b4dbba,stroke:#333,stroke-width:1px</pre>

<p>This probably feels too abstract, so let me give a concrete example:<br>Let’s say we want to parse the following arithmetic expression: <strong>3 + 2 * 5</strong><br>At first stage, we will pass this text through lexer. After lexing, we would have the following stream of tokens:</p>
<pre class="mermaid">graph LR;
  A[3]-->B[operator '+']
  B-->C[2]
  C-->D[operator '*']
  D-->E[5]</pre>

<p>Then, the parser will traverse over the tokens and generate abstract syntax tree (AST), in our case, parsing would result with the following AST:</p>
<pre class="mermaid">graph TB
  A(2)-->B{*}
  C(5)-->B
  B-->D{+}
  E(3)-->D</pre>
<p>In order to evaluate such expression, we would use DFS to traverse the AST, first evaluating <strong>2 * 5</strong>, then evaluating <strong>result + 3</strong>.<br>That’s nice, but show me the code, perhaps? Ok!</p>
<h2 id="Hello-ANTLR"><a href="#Hello-ANTLR" class="headerlink" title="Hello ANTLR"></a>Hello ANTLR</h2><p>The idea behind ANTLR is to create special syntax that would define tokens for the lexer and the grammar for the parser. In the code used here, for convenience I used a combined grammar that allows defining both tokens and grammar in one file. (Read more about ANTLR grammar structure <a target="_blank" rel="noopener" href="https://github.com/antlr/antlr4/blob/master/doc/grammars.md">here</a>)  </p>
<h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><p>First, we define the tokens for lexing. Here are their definitions:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//At the beginning of combined grammar file we need to declare the grammar name</span><br><span class="line">//Note that the grammar name must be the same as grammar filename</span><br><span class="line">grammar Algebra;</span><br><span class="line"></span><br><span class="line">//start token definitions</span><br><span class="line"></span><br><span class="line">//fragment is a kind of a function</span><br><span class="line">fragment DIGIT: [0-9];</span><br><span class="line"></span><br><span class="line">PLUS: &#x27;+&#x27;;</span><br><span class="line">MINUS: &#x27;-&#x27;;</span><br><span class="line">MULTIPLY: &#x27;*&#x27;;</span><br><span class="line">DIVIDE: &#x27;/&#x27;;</span><br><span class="line">POWER: &#x27;^&#x27;;</span><br><span class="line"></span><br><span class="line">LPAREN: &#x27;(&#x27;;</span><br><span class="line">RPAREN: &#x27;)&#x27;;</span><br><span class="line">COMMA: &#x27;,&#x27;;</span><br><span class="line"></span><br><span class="line">SIN: &#x27;sin&#x27;;</span><br><span class="line">COS: &#x27;cos&#x27;;</span><br><span class="line">TAN: &#x27;tan&#x27;;</span><br><span class="line">LOG: &#x27;log&#x27;;</span><br><span class="line"></span><br><span class="line">//token definition for integer number. Recognizes number of any length</span><br><span class="line">//</span><br><span class="line">//for this token, the idea is that the lexer would consume characters </span><br><span class="line">//from the input stream until they fit the &#x27;DIGIT&#x27; fragment definition</span><br><span class="line">INTEGER: DIGIT+;</span><br><span class="line"></span><br><span class="line">//token definition for floating point number </span><br><span class="line">FLOAT: DIGIT+ &#x27;.&#x27; DIGIT+;</span><br></pre></td></tr></table></figure>

<p>When ANTLR is called with the above lexer grammar, it would use the token definitions to generate a class, in this case <code>AlgebraLexer</code>.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">AlgebraLexer</span> : <span class="title">Lexer</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//define constants for tokens defined in the grammar</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span></span><br><span class="line">		PLUS=<span class="number">1</span>, MINUS=<span class="number">2</span>, MULTIPLY=<span class="number">3</span>, DIVIDE=<span class="number">4</span>, POWER=<span class="number">5</span>, LPAREN=<span class="number">6</span>, RPAREN=<span class="number">7</span>, COMMA=<span class="number">8</span>, </span><br><span class="line">		SIN=<span class="number">9</span>, COS=<span class="number">10</span>, TAN=<span class="number">11</span>, LOG=<span class="number">12</span>, INTEGER=<span class="number">13</span>, FLOAT=<span class="number">14</span>;</span><br></pre></td></tr></table></figure>

<p>And then, you’d see the following weirdness in the generated lexer:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> SerializedAtn &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _serializedATN; &#125; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serializedATN =</span><br><span class="line">		<span class="string">&quot;\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x2\x10S\b\x1\x4\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\t\x10\x3\x2\x3\x2\x3\x3\x3\x3\x3\x4\x3\x4\x3\x5\x3\x5\x3\x6\x3\x6\x3&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\a\x3\a\x3\b\x3\b\x3\t\x3\t\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\f\x3\f\x3&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\f\x3\f\x3\r\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xF\x6\xF\x45\n&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\xF\r\xF\xE\xF\x46\x3\x10\x6\x10J\n\x10\r\x10\xE\x10K\x3\x10\x3\x10\x6&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x10P\n\x10\r\x10\xE\x10Q\x2\x2\x2\x11\x3\x2\x2\x5\x2\x3\a\x2\x4\t\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x5\v\x2\x6\r\x2\a\xF\x2\b\x11\x2\t\x13\x2\n\x15\x2\v\x17\x2\f\x19\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\r\x1B\x2\xE\x1D\x2\xF\x1F\x2\x10\x3\x2\x3\x3\x2\x32;T\x2\x5\x3\x2\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2\a\x3\x2\x2\x2\x2\t\x3\x2\x2\x2\x2\v\x3\x2\x2\x2\x2\r\x3\x2\x2\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\xF\x3\x2\x2\x2\x2\x11\x3\x2\x2\x2\x2\x13\x3\x2\x2\x2\x2\x15\x3\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2\x2\x17\x3\x2\x2\x2\x2\x19\x3\x2\x2\x2\x2\x1B\x3\x2\x2\x2\x2\x1D&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x3\x2\x2\x2\x2\x1F\x3\x2\x2\x2\x3!\x3\x2\x2\x2\x5#\x3\x2\x2\x2\a%\x3&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2\x2\t\&#x27;\x3\x2\x2\x2\v)\x3\x2\x2\x2\r+\x3\x2\x2\x2\xF-\x3\x2\x2\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x11/\x3\x2\x2\x2\x13\x31\x3\x2\x2\x2\x15\x33\x3\x2\x2\x2\x17\x37\x3\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2\x19;\x3\x2\x2\x2\x1B?\x3\x2\x2\x2\x1D\x44\x3\x2\x2\x2\x1FI\x3\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2!\&quot;\t\x2\x2\x2\&quot;\x4\x3\x2\x2\x2#$\a-\x2\x2$\x6\x3\x2\x2\x2%&amp;\a/&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2&amp;\b\x3\x2\x2\x2\&#x27;(\a,\x2\x2(\n\x3\x2\x2\x2)*\a\x31\x2\x2*\f\x3\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2+,\a`\x2\x2,\xE\x3\x2\x2\x2-.\a*\x2\x2.\x10\x3\x2\x2\x2/\x30\a+&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2\x30\x12\x3\x2\x2\x2\x31\x32\a.\x2\x2\x32\x14\x3\x2\x2\x2\x33\x34&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\au\x2\x2\x34\x35\ak\x2\x2\x35\x36\ap\x2\x2\x36\x16\x3\x2\x2\x2\x37\x38&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\a\x65\x2\x2\x38\x39\aq\x2\x2\x39:\au\x2\x2:\x18\x3\x2\x2\x2;&lt;\av\x2\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;&lt;=\a\x63\x2\x2=&gt;\ap\x2\x2&gt;\x1A\x3\x2\x2\x2?@\an\x2\x2@\x41\aq\x2\x2\x41&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x42\ai\x2\x2\x42\x1C\x3\x2\x2\x2\x43\x45\x5\x3\x2\x2\x44\x43\x3\x2\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x45\x46\x3\x2\x2\x2\x46\x44\x3\x2\x2\x2\x46G\x3\x2\x2\x2G\x1E\x3\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2HJ\x5\x3\x2\x2IH\x3\x2\x2\x2JK\x3\x2\x2\x2KI\x3\x2\x2\x2KL\x3\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2LM\x3\x2\x2\x2MO\a\x30\x2\x2NP\x5\x3\x2\x2ON\x3\x2\x2\x2PQ\x3\x2&quot;</span>+</span><br><span class="line">		<span class="string">&quot;\x2\x2QO\x3\x2\x2\x2QR\x3\x2\x2\x2R \x3\x2\x2\x2\x6\x2\x46KQ\x2&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> ATN _ATN =</span><br><span class="line">		<span class="keyword">new</span> ATNDeserializer().Deserialize(_serializedATN.ToCharArray());</span><br></pre></td></tr></table></figure>

<p><em>ATN</em> stands for <em>Augmented Transition Networks</em> - a state machine generated by ANTLR to parse tokens and grammar rules.<br>For example, this is the states generated to parse ‘+’ operator:<br><object data="PLUS.atn.svg" type="image/xml+svg"><br>    <!-- Your browser doesn't support rendering of SVG --><br>    <img src="PLUS.atn.png" alt="ATN for '+' token"><br></object></p>
<p>Now, what if we have a more complex token? For example, how would lexer token definition look like for a C-style double quoted string?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fragment D_STRING: &#x27;&quot;&#x27; ( &#x27;\\&#x27;. | &#x27;&quot;&quot;&#x27; | ~(&#x27;&quot;&#x27;| &#x27;\\&#x27;) )*? &#x27;&quot;&#x27;;</span><br></pre></td></tr></table></figure>
<p>The idea here is roughly similar to regex definition: we define starting and stopping character of the token (which are double quotes), then tell ANTLR to greedily parse any characters except <code>&quot;</code> or <code>\</code> (this is done by using ‘*’ that specifies ‘greedy’ parsing strategy)<br>This could be illustrated by what is sometimes called “railroad diagram”:<br><object data="D_STRING.rrd.svg" type="image/xml+svg"><br>    <!-- Your browser doesn't support rendering of SVG --><br>    <img style="width=100%" src="D_STRING.rrd.png" alt="Parsing diagram for double quoted string token"><br></object></p>
<p>As you can imagine, the ATN for such token is more… interesting.<br><object data="D_STRING.atn.svg" type="image/xml+svg"><br>    <!-- Your browser doesn't support rendering of SVG --><br>    <img src="D_STRING.atn.png" alt="ATN for double quoted string token"><br></object></p>
<h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>After we defined tokens, let’s define grammar rules by which the parser will do the generation.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//parsing rules definitions</span><br><span class="line">//root expression to parse, this is the starting point of the parser</span><br><span class="line">root: expression EOF;</span><br><span class="line"></span><br><span class="line">// This is a *recusive* rule to parse types of expressions we support.</span><br><span class="line">// Conceptually, this is evaluated from top down: the parser tries to match the first one (which is NumberExpression).</span><br><span class="line">// If it fails, the parser will try the next one. And so on..</span><br><span class="line">expression:</span><br><span class="line">   (INTEGER | FLOAT)                                                  #NumberExpression         |</span><br><span class="line">   MINUS num = expression                                           #NegativeNumberExpression   |</span><br><span class="line">   num = expression POWER pow = expression                             #PowerExpression         |</span><br><span class="line">   LPAREN expression RPAREN                                         #ParenthesisExpression      |</span><br><span class="line">   SIN LPAREN num = expression RPAREN                                  #SinusExpression         |</span><br><span class="line">   COS LPAREN num = expression RPAREN                                #CosinusExpression         |</span><br><span class="line">   TAN LPAREN num = expression RPAREN                                #TangentExpression         |</span><br><span class="line">   LOG LPAREN num = expression COMMA base = expression RPAREN         #LogarithmExpression      |</span><br><span class="line">   //notice that we put handling of multiplication and division first and then addition and substraction</span><br><span class="line">   //this is needed to establish operator precedence </span><br><span class="line">   //In this way, for expression &#x27;2 + 3 * 5&#x27;, first 3*5 will be evaluated and then &#x27;result&#x27; + 2</span><br><span class="line">   left = expression op = (MULTIPLY | DIVIDE) right = expression   #MultOrDivideExpression      |</span><br><span class="line">   left = expression op = (PLUS | MINUS) right = expression        #PlusOrMinusExpression      </span><br><span class="line">   ;</span><br></pre></td></tr></table></figure>

<p>The same kind of ATN is generated for parsing grammar rules. For example, the defined above <code>expression</code> rule will have the following (huge!) ATN:<br><object data="expression.atn.svg" type="image/xml+svg"><br>    <!-- Your browser doesn't support rendering of SVG --><br>    <img src="expression.atn.png" alt="ATN for double quoted string token"><br></object></p>
<p>Now, lets take a look at the code ANTLR actually generates. I think this can be avery good illustration at what ATN <em>is</em>.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> ExpressionContext <span class="title">expression</span>(<span class="params"><span class="built_in">int</span> _p</span>)</span> &#123;</span><br><span class="line">     <span class="comment">// some initialization code</span></span><br><span class="line">     EnterRecursionRule(_localctx, <span class="number">2</span>, RULE_expression, _p);</span><br><span class="line">     <span class="built_in">int</span> _la;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> _alt;</span><br><span class="line">        EnterOuterAlt(_localctx, <span class="number">1</span>);</span><br><span class="line">        &#123;</span><br><span class="line">        State = <span class="number">37</span>;</span><br><span class="line">        _errHandler.Sync(<span class="keyword">this</span>);</span><br><span class="line">	 <span class="comment">//_input is a stream of tokens received from the lexer</span></span><br><span class="line">	 <span class="comment">//here we look ahead 1 character and decide what kind of sub-rule we want to TRY and parse</span></span><br><span class="line">	 <span class="comment">//notice that we do not *consume* characters (the Consume() method) until we are sure it is the right rule</span></span><br><span class="line">        <span class="keyword">switch</span> (_input.La(<span class="number">1</span>)) &#123;</span><br><span class="line">	 <span class="comment">//note: INTEGER and FLOAT are tokens defined in the lexer</span></span><br><span class="line">        <span class="keyword">case</span> INTEGER: </span><br><span class="line">        <span class="keyword">case</span> FLOAT:</span><br><span class="line">           &#123;</span><br><span class="line">		<span class="comment">//notice that the context is the &#x27;#NumberExpression&#x27; we had in the rule definition</span></span><br><span class="line">           _localctx = <span class="keyword">new</span> NumberExpressionContext(_localctx);</span><br><span class="line">           _ctx = _localctx;</span><br><span class="line">           _prevctx = _localctx;</span><br><span class="line"></span><br><span class="line">           State = <span class="number">8</span>; <span class="comment">//set ATN state</span></span><br><span class="line">           _la = _input.La(<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span> ( !(_la==INTEGER || _la==FLOAT) ) &#123;</span><br><span class="line">           _errHandler.RecoverInline(<span class="keyword">this</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (_input.La(<span class="number">1</span>) == TokenConstants.Eof) &#123;</span><br><span class="line">                 matchedEOF = <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              _errHandler.ReportMatch(<span class="keyword">this</span>);</span><br><span class="line">              Consume(); <span class="comment">//only here we actualy consume </span></span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MINUS:</span><br><span class="line">           &#123;</span><br><span class="line">		<span class="comment">//notice that this matches &#x27;#NegativeNumberExpression&#x27; defined in the rule</span></span><br><span class="line">           _localctx = <span class="keyword">new</span> NegativeNumberExpressionContext(_localctx);</span><br><span class="line">           _ctx = _localctx;</span><br><span class="line">           _prevctx = _localctx;</span><br><span class="line">		<span class="comment">//set ATN state and try to match a token against current input symbol</span></span><br><span class="line">           State = <span class="number">9</span>; Match(MINUS); </span><br><span class="line">           State = <span class="number">10</span>; ((NegativeNumberExpressionContext)_localctx).num = expression(<span class="number">9</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//more code for the rule...</span></span><br></pre></td></tr></table></figure>
<p>That scary bunch of code looks a bit complex, but if you look closely it is rather simple (though still ugly!).<br>First, we enter the rule and set the state machine to the inital state of the particular rule</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnterRecursionRule(_localctx, <span class="number">2</span>, RULE_expression, _p);</span><br><span class="line"><span class="built_in">int</span> _la;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="built_in">int</span> _alt;</span><br><span class="line">   EnterOuterAlt(_localctx, <span class="number">1</span>);</span><br><span class="line">   &#123;</span><br><span class="line">   State = <span class="number">37</span>; <span class="comment">//initial state of the state machine</span></span><br><span class="line">   _errHandler.Sync(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>Then we use the next token in the stream to select the “sub-rule” we have at this particular point of the source code we are parsing</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (_input.La(<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>Then, if we have an INTEGER or a FLOAT token, we switch the current context to the “sub-rule” context, </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> INTEGER: </span><br><span class="line">      <span class="keyword">case</span> FLOAT:</span><br><span class="line">         &#123;</span><br><span class="line"><span class="comment">//notice that the context is the &#x27;#NumberExpression&#x27; we had in the rule definition</span></span><br><span class="line">         _localctx = <span class="keyword">new</span> NumberExpressionContext(_localctx);</span><br></pre></td></tr></table></figure>

<p>After switching the context, we cache the next character and “consume” the token from lexer stream (consuming means we mark the token as parsed, add it to resulting AST and continue)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">State = <span class="number">8</span>; <span class="comment">//set ATN state for this &quot;sub-rule&quot;</span></span><br><span class="line">_la = _input.La(<span class="number">1</span>); <span class="comment">//cache the next token in lexer stream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//do some error handling in case the syntax is wrong</span></span><br><span class="line"><span class="comment">//note how we try to recover so despite syntax errors we parse ALL of the source code</span></span><br><span class="line"><span class="keyword">if</span> ( !(_la==INTEGER || _la==FLOAT) ) &#123;</span><br><span class="line">_errHandler.RecoverInline(<span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (_input.La(<span class="number">1</span>) == TokenConstants.Eof) &#123;</span><br><span class="line">      matchedEOF = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//register match for the &quot;sub-rule&quot; --&gt; this essentially adds node to AST</span></span><br><span class="line">   _errHandler.ReportMatch(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//mark the token as consumed and remove from lexer&#x27;s token stream</span></span><br><span class="line">   Consume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Well… thats it! Roughly, all rules are parsed in this way, the only thing that differs is how next rules for the state machine are predicted (ANTLR has different <a target="_blank" rel="noopener" href="https://www.antlr.org/api/Java/org/antlr/v4/runtime/atn/PredictionMode.html">prediction modes</a> that affect ambiguity resolution, among other things) and how errors are treated (see error handling strategy link below).  </p>
<p>Now, the nice thing in ANTLR generated parsers is their ability to continue parsing even if the input is partially incorrect. The method <code>Parser::Match()</code> (which is used in grammar rule parsing) illustrates this well. Notice how it registers the error, tries to recover and returns <em>bad token</em> so the parsing can continue.  </p>
<blockquote>
<p>This behavior can be changed by implementing different <a target="_blank" rel="noopener" href="https://www.antlr.org/api/Java/org/antlr/v4/runtime/ANTLRErrorStrategy.html">error handling strategies</a> but this is out of the scope of this post.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">return: NotNull</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IToken <span class="title">Match</span>(<span class="params"><span class="built_in">int</span> ttype</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IToken badToken = <span class="keyword">this</span>.CurrentToken;</span><br><span class="line">    <span class="keyword">if</span> (badToken.Type == ttype)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (ttype == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">this</span>.matchedEOF = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>._errHandler.ReportMatch(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.Consume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    badToken = <span class="keyword">this</span>._errHandler.RecoverInline(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._buildParseTrees &amp;&amp; badToken.TokenIndex == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">this</span>._ctx.AddErrorNode(badToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> badToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Using-the-parser"><a href="#Using-the-parser" class="headerlink" title="Using the parser"></a>Using the parser</h2><p>Once we have a parsed our grammar and generated an AST, we need to evaluate it. Usually, this is done by using a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> to walk over AST (in a DFS-y way) and evaluate it.<br>In order to do that, ANTLR generates visitor classes, where each rule expression can be ‘visited’. In our case, algebra expression evaluation would look this:</p>
<blockquote>
<p>Just in case you are not familiar with C# 8 syntax: in this sample I am using the new <code>switch expressions</code> syntax. You can read more about them <a target="_blank" rel="noopener" href="https://dotnetcoretutorials.com/2019/06/25/switch-expressions-in-c-8/">here</a>.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExpressionEvaluationVisitor</span> : <span class="title">AlgebraBaseVisitor</span>&lt;<span class="title">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitPowerExpression</span>(<span class="params">AlgebraParser.PowerExpressionContext context</span>)</span> =&gt; </span><br><span class="line">        Math.Pow(<span class="keyword">base</span>.Visit(context.num), (<span class="built_in">int</span>)<span class="keyword">base</span>.Visit(context.pow));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitNumberExpression</span>(<span class="params">AlgebraParser.NumberExpressionContext context</span>)</span> =&gt; </span><br><span class="line">        <span class="built_in">double</span>.Parse(context.GetText(), NumberStyles.Any);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitMultOrDivideExpression</span>(<span class="params">AlgebraParser.MultOrDivideExpressionContext context</span>)</span> =&gt;</span><br><span class="line">        context.op.Text <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;*&quot;</span> =&gt; (<span class="keyword">base</span>.Visit(context.left) * <span class="keyword">base</span>.Visit(context.right)),</span><br><span class="line">            <span class="string">&quot;/&quot;</span> =&gt; (<span class="keyword">base</span>.Visit(context.left) / <span class="keyword">base</span>.Visit(context.right)),</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;Unsupported operator &#x27;<span class="subst">&#123;context.op.Text&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitPlusOrMinusExpression</span>(<span class="params">AlgebraParser.PlusOrMinusExpressionContext context</span>)</span> =&gt;</span><br><span class="line">        context.op.Text <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;+&quot;</span> =&gt; (<span class="keyword">base</span>.Visit(context.left) + <span class="keyword">base</span>.Visit(context.right)),</span><br><span class="line">            <span class="string">&quot;-&quot;</span> =&gt; (<span class="keyword">base</span>.Visit(context.left) - <span class="keyword">base</span>.Visit(context.right)),</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;Unsupported operator &#x27;<span class="subst">&#123;context.op.Text&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitCosinusExpression</span>(<span class="params">AlgebraParser.CosinusExpressionContext context</span>)</span> =&gt; </span><br><span class="line">        Math.Cos(<span class="keyword">base</span>.Visit(context.num));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitLogarithmExpression</span>(<span class="params">AlgebraParser.LogarithmExpressionContext context</span>)</span> =&gt; </span><br><span class="line">        Math.Log(<span class="keyword">base</span>.Visit(context.num), <span class="keyword">base</span>.Visit(context.@base));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitTangentExpression</span>(<span class="params">AlgebraParser.TangentExpressionContext context</span>)</span> =&gt; </span><br><span class="line">        Math.Tan(<span class="keyword">base</span>.Visit(context.num));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitSinusExpression</span>(<span class="params">AlgebraParser.SinusExpressionContext context</span>)</span> =&gt; </span><br><span class="line">        Math.Sin(<span class="keyword">base</span>.Visit(context.num));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">VisitNegativeNumberExpression</span>(<span class="params">AlgebraParser.NegativeNumberExpressionContext context</span>)</span> =&gt; </span><br><span class="line">        <span class="number">-1</span> * <span class="keyword">base</span>.Visit(context.num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">AggregateResult</span>(<span class="params"><span class="built_in">double</span> aggregate, <span class="built_in">double</span> nextResult</span>)</span> =&gt; </span><br><span class="line">        aggregate + nextResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>As you can see, writing parsers might seem daunting at first, but in reality it is not a very hard task. Of course there is a notion of user-friendly error handling, ensuring proper ambiguity resolution and other stuff, but I think for a “hello world” tutorial the above code should be enough.<br>You can take a look at the whole sample project here: <a target="_blank" rel="noopener" href="https://github.com/myarichuk/AlgebraExpressionEvaluator">https://github.com/myarichuk/AlgebraExpressionEvaluator</a>. In case you’d like to compile and run it, note that it targets .Net Core 3.0</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C#</a><a class="post-meta__tags" href="/tags/ANTLR/">ANTLR</a><a class="post-meta__tags" href="/tags/Parsers/">Parsers</a></div><div class="post_share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/25/opencv-and-cmake-in-cpp/" title="OpenCV + Visual Studio + CMake = Adventure time"><div class="cover" style="background: url(/2019/12/17/cryptic-cmake-errors/cover.png)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">OpenCV + Visual Studio + CMake = Adventure time</div></div></a></div><div class="next-post pull-right"><a href="/2019/12/17/rarely-used-task-continuation/" title="Even simple stuff, like C# TPL can surprise you!"><div class="cover" style="background: url(/2019/12/17/rarely-used-task-continuation/cover.jpg)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Even simple stuff, like C# TPL can surprise you!</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/1473701" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Michael Yarichuk</div><div class="author-info__description">A place to share steps in my journey to become a better professional</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/myarichuk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/myarichuk" target="_blank" title=""><i class="fa-brands fa-github"></i></a><a class="social-icon" href="mailto:michael.yarichuk@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="https://twitter.com/myarichuk" target="_blank" title=""><i class="fa-brands fa-twitter"></i></a><a class="social-icon" href="https://www.linkedin.com/in/myarichuk/" target="_blank" title=""><i class="fa-brands fa-linkedin"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-word-or-two-on-what-parsers-are"><span class="toc-number">1.</span> <span class="toc-text">A word (or two) on what parsers are</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-ANTLR"><span class="toc-number">2.</span> <span class="toc-text">Hello ANTLR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lexer"><span class="toc-number">2.1.</span> <span class="toc-text">Lexer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parser"><span class="toc-number">2.2.</span> <span class="toc-text">Parser</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Using-the-parser"><span class="toc-number">3.</span> <span class="toc-text">Using the parser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">4.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/15/production-ready-logging-monitoring/" title="'Production Ready' Non-Negotiable: Structured Logging and Monitoring"><img src="/2023/11/15/production-ready-logging-monitoring/production-ready-2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="'Production Ready' Non-Negotiable: Structured Logging and Monitoring"/></a><div class="content"><a class="title" href="/2023/11/15/production-ready-logging-monitoring/" title="'Production Ready' Non-Negotiable: Structured Logging and Monitoring">'Production Ready' Non-Negotiable: Structured Logging and Monitoring</a><time datetime="2023-11-15T23:00:00.000Z" title="Created 2023-11-15 23:00:00">2023-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/15/templates-ftw/" title="Disentangling the Spaghetti Monster"><img src="/2023/11/15/templates-ftw/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Disentangling the Spaghetti Monster"/></a><div class="content"><a class="title" href="/2023/11/15/templates-ftw/" title="Disentangling the Spaghetti Monster">Disentangling the Spaghetti Monster</a><time datetime="2023-11-15T00:43:21.553Z" title="Created 2023-11-15 00:43:21">2023-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/production-ready-intro/" title="Production-Ready Software: Introduction"><img src="/2023/11/11/production-ready-intro/production_ready_background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Production-Ready Software: Introduction"/></a><div class="content"><a class="title" href="/2023/11/14/production-ready-intro/" title="Production-Ready Software: Introduction">Production-Ready Software: Introduction</a><time datetime="2023-11-14T19:15:48.000Z" title="Created 2023-11-14 19:15:48">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/10/responsibility-chain/" title="Taming Complexity with Responsibility"><img src="/2023/11/10/responsibility-chain/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Taming Complexity with Responsibility"/></a><div class="content"><a class="title" href="/2023/11/10/responsibility-chain/" title="Taming Complexity with Responsibility">Taming Complexity with Responsibility</a><time datetime="2023-11-10T23:00:00.000Z" title="Created 2023-11-10 23:00:00">2023-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/09/ecs-intro/" title="From Inheritance Hell to Component Heaven, the ECS Pattern"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="From Inheritance Hell to Component Heaven, the ECS Pattern"/></a><div class="content"><a class="title" href="/2023/11/09/ecs-intro/" title="From Inheritance Hell to Component Heaven, the ECS Pattern">From Inheritance Hell to Component Heaven, the ECS Pattern</a><time datetime="2023-11-09T23:00:00.000Z" title="Created 2023-11-09 23:00:00">2023-11-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Michael Yarichuk</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://www.graymatterdeveloper.com/2019/12/25/writing-parsers-easier-than-you-think/'
    this.page.identifier = '/2019/12/25/writing-parsers-easier-than-you-think/'
    this.page.title = 'Hello ANTLR (writing parsers is easier than you think!)'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://graymatterdeveloperblog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-R5G4WP4QCQ"></script><script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-R5G4WP4QCQ') </script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>